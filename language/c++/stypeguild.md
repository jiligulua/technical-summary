摘抄《google C++风格指南》的笔记

# 1.头文件
- 头文件要能够自给自足，用户和重构工具不需要为特别场合而包含额外的头文件。
- 所有头文件应该有#define保护，格式为：\<PROJECT>\_\<PATH>\_\<FILE>\_H\_
- 尽可能避免使用前置声明，使用#inlcude包含需要的头文件即可。其优点节省编译时间和重新编译的时间，缺点是会隐藏依赖关系，可能会被库的后续更改所破坏，前置声明来自命名空间std::的symbol时，其行为未定义，极端情况下前置声明代替#include会暗暗改变代码的含义。仅仅为了前置声明而重构代码（如用指针成员代替对象成会）会使代码变得更慢更复杂。

	尽量避免前置声明那么定义在其它项目中的实体
	函数总是使用#include，类模板优先使用#include

- 内联函数：只有当函数只有10行甚么更少时才将其定义为内联函数。
对于函数体比较短，性能关键的函数，鼓励使用内联。现代处理器由于更好的利用了指令的缓存，小巧的代码往往执行更快。

	内联那些包含循环或switch语句的函数，常常是得不偿失（除非在大多数情况下，这些循环或switch语句从不执行）

	有些函数即使声明为内联的也不一定会被编译器内联，如虚函数和递归函数不会被正常内联。

- #include的路径及顺序

顺序是本类的声明，C系统文件，C++系统文件，其它库文件和本项目内头文件，除第一个之外，之后的都按时间序排列，同级别按字母序二次排列。所依赖的符号被哪些头文件定义，就直接写出包含哪些头文件，不能使用间接包含的头文件替代。注意，普通文件用双引号，库文件用尖括号。

平台特定的条件预定义判断放在include之后，如#ifdef ... #include...  #endif

前置声明的类是不完全类型，我们只能定义指向该类型的指针或引用，或声明（但不能定义）以不完全类型作为参数或者返回类型的函数。编译器不知道不完全类型的定义，不能创建其类的任何对象，也不能声明成类内部的数据成岩。

类内部的函数一般会自动内联，所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放在.cc文件里。#include中插入空行，分割相关头文件，C库，C++库，其它库的.h和本项目内的.h是个好习惯

# 2 作用域

- 命名空间：鼓励在.cc文件内使用匿名命名空间或static声明，使用具名命名空间时，其名称可基于项目名或相对路径，禁止使用using指示，禁止使用内联命名空间（会自动将内部的标识符放到外层作用域中）

在命名空间的最后注释出命名空间的名字。用命名空间把文件包括：gflag所的声明/定义，以及类的前置声明以外地的整个源文件封装起来，以去被于其它命名空间。命名空间的namespace和内部代码左对齐。

不应该使用using指示引入整个命名空间的标识符号,这样会污染命名空间。

在.cc文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为static，但不要在.h文件中这样做。置于匿名命名空间的声明具有于当前.cc文件具有内部链接性。

- 非成员函数、静态成员函数和全局函数
放在某一个命名空间中，比单纯的将它们放在一个类中并声明为static要好，不要用类+静态函数来模拟命名空间

所有的命名空间都顶格写，且于所有的函数或类对齐。

若必须定义非成员函数，又只能是在.cc文件中使用它，可使用匿名命名空间或static链接关键字限定（如static int Foo() {...}）其作用域。

- 局部变量
	将函数变量尽可能置于最小作用域内，并在变量声明时进行初始化。
属于if,while和for语句的变量应当在这些语句中正常声明，有一个例外，若果变量是一个对象，每次进出都要构造析构，会导致效率低下。

- 静态和全局变量

禁止使用类的静态存储周期变量，由于构造和析构函数调用顺序的不确定性，会导致难以发现的bug。静态生存周期的对象包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型（POD：Plain Old Data），即int, char和float，以仅POD类型的指针、数组和结构体。不允许用函数返回值来初始化POD变量，除非该函数不涉及任何全局变量。函数作用域里的静态变量除外。

全局和静态变量在程序中断时会被析构，无论中断从main()返回还是对exit()的调用。析构顺序正好与构造函数调用顺序相反，既然构造顺序未定义，那么析构函数也不确定。若程序结束时某静态变量已析构，但代码还在跑，如线程还在，而该线程中试图访问这些静态或全局变量将会失败，在比如一个静态的string变量，容易发生异常。

改善以上析构问题的办法之一是用quick_exit()来代替exit()并中断程序。前者不执行析构函数，也不会执行atexit()所绑定的任何handlers。若想在执行quick_exit()来中断时执行某handler（如刷新log），可绑定到_at_quick_exit()。如果您想在exit()和quick_exit()都用上该handler，都绑定上去。

综上，只允许POD类型的静态变量，即完全禁止vector（使用C数组替代）和string（使用const char[]）

如果确实需要一个class类型的静态或全局变量，可考虑在main()函数或pthread_once()内初始化一个指针且永不回收。注意只能用raw指针，不用智能指针，毕竟后者的析构函数存在不定顺序的问题。

多线程中的全局变量（含静态成员变量）不使用class类型（含STL容器），避免不明确行为导致的bug
作用域的使用，除了考虑名称污染，可读性之外，主要是为了降低耦合，提高编译/执行效率。

注意using指示和using声明的区别，匿名命名空间就是文件作用域，局部变量在声明的同时就显示值初始化，注意别在循环犯大量构造和析构的低级错误。

# 类
- 构造函数内不应调用虚函数，即便调用了也不会重定向到子类的虚函数
- 单参数的构造函数使用explicit，多参数不加explict。当接受一个std::initializer_list作为参数的构造函数也应当省略explicit，以便支持拷贝初始化（如：MyType m = {1, 2}; ）
- 可拷贝类型和可移动类型，若类型需要，就让它们支持拷贝/移动，否则就把隐式产生的拷贝和移动函数禁用。所有可拷贝对象也是可移动的。std::unique_ptr<int>就是一个可移动但不可复制的对象的例子。

可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回，这使得API更简单，更安全也更通用。与传指针和引用不同，这样的传递不会造成所有权，生命周期，可变性等方面的混乱。也防止了客户端与实现在非作用域内的交互，使得它们更容易被理解与维护。

移动操作允许隐式且高效地将源数据转移除右值对象，这有时能让代码风格更加清晰。

由于存在对象切割的风险，不要为任何有可能有派生类的对象提供拷贝/移动构造函数和相应的赋值运算符，如果你的基类可复制属性，请提供一个public virtual Clone()和一个protect的拷贝构造函数以供派生类实现。如果类不需要拷贝/移动操作，必须显示地通过public域中使用=delete或其它手段禁用

	// MyClass is neither copyable nor movable.
	MyClass(const MyClass&) = delete;
	MyClass& operator=(const MyClass&) = delete;

- 结构体vs类
只有数据成员时使用struct，其它一概使用class。为了和STL保持一致，对于仿函数等特性使用struct。它们使用不同的命名规则。

- 继承
使用组合比使用继承更好，如果使用继承的话，定义为public继承。继承只用于两种场合：实现继承，子类继承父类的实现代码；接口继承，子类仅继承父类的方法名称。接口继承是用来强制类输出特定的API。所以继承必须是public，若是想私有继承，应替换成把基类的实例作为成员对象。不要过度使用实现继承，组合常常更合适一些。如Bar的确是一种Foo，Bar才能继承Foo。若你的类有虚函数，析构函数必须是虚函数。对于可能被子类访问的成员函数，不要过度使用protected关键字，数据成员都必须是私有的。

对于重载的虚函数或虚析构函数，使用override，或（较不常用的）final关键字显示地进行标记。这些标记起到了文档的作用，因为如果省略这些关键字，代码阅读者不得不检查所有父类，以判断该函数是否是虚函数。

- 多重继承
真正需要用到多重实现继承的情况少之又少，只有在第一个基类是非抽象类，其它基类都是以Inteface为后缀的纯接口类才可用。要将作为纯接口的基类和具有实现的基类区分开来。


- 接口
纯接口以Interface为后缀（不强制）且满足如下4个条件：

-	只有纯虚函数（=0）和静态函数（除了虚析构函数）
-	没有非静态数据成员
-	没有定义任何构造函数，若有，也不能带有参数，并且必须为protected
-	若是一个子类，也只能从满足上述条件并以Interface为后缀的类继承

为确保接口类的所有实现可被正确销毁，必须声明虚析构函数，不能是纯虚函数必须为～BaseInterface() {}

- 运算符重载
通过使用operator对内建运算符进行重载定义。operator关键字允许用户使用operator""定义新的字面运算符，并且定义类型转换函数，如operator bool()。它可让代码更简洁。对于创建用户定义的类型的对象来说，用户定义字面量(也叫自定义后缀名操作符)是一种非常简洁的标记。如

	//只是举例，不追求合理性和效率性
	std::vector<std::string> operator""[此处有空格] _C(const _In_ char* pData, IN size_t nSize) {
		std::vector<std::string> vResult;
		//假设对字符串进行切割
		//比如"a1;b1;c1;d1"根据‘;’切割成  a1  b1  c1  d1 四个字符串
		return vResult;
	}
	
	//使用
	std::vector<std::string> vRes = "a1;b1;c1;d1"_C
	//vRes = {"a1","b1","c1","d1"}


	自定义字面量的限制
	C++11 只允许字面量后缀函数的参数为以下类型，即整数，浮点以及字符串：
	
	unsigned long long
	long double
	char const*
	char const*, std::size_t
	wchar_t const*, std::size_t
	char16_t const*, std::size_t
	char32_t const*, std::size_t



不要重载 &&, ||, , 或一元运算符 &. 不要重载 operator"", 也就是说, 不要引入用户定义字面量.

- 存取控制
将所有数据成员声明为private, 除非是static const类型成员 (遵循 常量命名规则). 出于技术上的原因, 在使用 Google Test 时我们允许测试固件类中的数据成员为 protected.

- 声明顺序
将相似的声明放在一起，将public部分放在最前，类定义一般以public、protected最后为private的顺序。将类似的声明放在一起，顺序为：类型（typedef、using和嵌套的结构体与类），常量，工厂函数，构造函数，赋值运算符，析构函数，其它函数，数据成员。通常只有那些普通的，或性能关键且短小的函数可以内联在类定义中。


不在构造函数中做太多逻辑相关的初始化;
编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;
为避免隐式转换, 需将单参数构造函数声明为 explicit;
为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现，现在可以用delete，更方便。
仅在作为数据集合时使用 struct;
组合 > 实现继承 > 接口继承 > 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做;
避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;
接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 protected;
为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;
存取函数一般内联在头文件中;
声明次序: public -> protected -> private;
函数体尽量短小, 紧凑, 功能单一;

# 4 函数

- 输入和输出
倾向于按值返回，否则按引用返回。避免返回指针，除非它可以为空。倾向于使用返回值而不是输出参数，这样提高可读性并且通常提供相同或更好的性能。


	在 C++ 11 中新增了 tuple 这种数据结构的支持，自然也可以使用 tuple 来实现多个返回值
	
	#include <iostream>
	#include <tuple>
	
	using namespace std;
	
	tuple<bool, string, string> func(const string& in) {
	    if (in.size() == 0)
	        return make_tuple(false, "", "");
	    return make_tuple(true, "hello", "world");
	}
	
	int main() {
	    if (auto [status, out1, out2] = func("hi"); status) {
	        cout << out1 << endl;
	        cout << out2 << endl;
	    }
	    return 0;
	}
	上面这段代码中的 `auto [status, out1, out2] = func("hi");` 是 C++ 17 中叫 Structured Bindings 的新特性，效果就是将多个返回值按照顺序绑定到方括号中的变量名中。
	在 CppCoreGuidelines 中对于多返回值更建议使用 tuple 或 struct ，这样做能让返回值的语意更加明确。

std::optional 是在 C++ 17 中引入到标准库中的，C++ 17 之前的版本可以通过 boost::optional 实现几乎相同的功能。











