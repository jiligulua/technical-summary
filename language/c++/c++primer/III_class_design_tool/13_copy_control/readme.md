## 拷贝控制操作

一个类通过5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁时做什么

1. 拷贝构造函数
需要拷贝操作的类也需要赋值操作，反之亦然。（例如：一个类为每个对象分配一个独有的、唯一的序号），都不必然需要析构函数。使用一个static成员为每个非静态的数据成员赋值，而每次发生拷贝构造或拷贝赋值时，先将static类成员变量加1，并赋值给非static成员变量，保证了每个类对象有唯一的一个标号。

2. 拷贝赋值运算符

重载运算符本质上是函数，其名字由operator关键字接表示要定义的运算符的符号组成，因此，赋值运算符就是一个名为operator=的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。

重载运算符的参数表示运算符的运算对象。


赋值运算符必须定义为成员函数，如果一个运算符是成员函数，其左侧运算对象就绑定到隐式的this参数。标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

3. 移动构造函数

4. 移动赋值运算符

5. 析构函数

析构函数的名字由波浪号接类名构成，没有返回值也不接受参数，因此它不能被重载。

析构函数首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。

析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。

需要析构函数的类也需要拷贝和赋值操作。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求要更明显。如果一个类需要析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值操作运算符




## 为什么要使用资源管理类呢？

1. 栈内存有限，需要使用堆内存，而堆内存理论上可以达到pow(2, 32)或pow(2, 64);

2. 使用资源管理类时，一般使用swap交换操作，可作为资源类的友元函数，而在拷贝赋值操作符中使用值传递，这样就实现了拷贝赋值操作符中使用了拷贝构造函数，以及自己的swap操作，而自己的swap操作中，可以使用std::swap，这样就得到了STL的加持，也考虑到了自赋值的情况，同时保证了异常安全性，即在调用拷贝构造函数时因为new而抛出异常的话，不会影响左侧对象原有的数据，因为抛出异常后，程序员进行了异常捕获（在使用构造函数时）。注意只有类值版本可以使用swap，而类指针版本不能够使用swap版本，因为类指针版本有引用计数，不能进行简单的交换。



当类要利用sort函数进行排序时，需要有两个函数，分别是`operator<` 和swap函数。在sort时需要交换数据，这个时候就需要进行swap交换数据。类指针的HasPtr版本也可以从swap函数受益。


## 拷贝控制示例

通常分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因，还有一些类也需要拷贝控制成员的帮助来进行薄记工作或其他操作。


通过swap可以避免对标准库容器成员的不必要拷贝，例如有个类，它有stl的成员，那么在实现拷贝赋值操作符时，利用自定义的swap可以将对stl容器成员进行std::swap处理，同时对特定的数据进行交换。

std::allocator<T> 就是一个内存管理的工具类，表现为内存分配和对象构造，对象析构和内存释放。根据不同的T生成相应对象的内存申请工具，通过allocate(n)，表示分配n块T的内存，返回内存首地址。

allocator<T> a;
auto p = a.allocate(n); // 分配n块T对象的内存
a.deallocate(p,n); // 释放从p开始的内存，共有n个类型为T的对象。

a.construct(p, args); // p必须为一个类型为T*的指针，arg被传递给类型为T的构造函数
a.destroy(p); // 对p指向的对象执行析构函数

allocator算法，这些函数在给定目的位置创建元素，而不是由系统分配内存给它们：
uninitialized_copy(b, e, b2);

uninitialized_copy_n(b, n, b2);

uninitialized_fill(b, e, t);

uninitialized_fill_n(b, n, t);

eg:  

	auto p = alloc.allocate(vi.size() * 2);
	auto q = uninitialized_copy(vi.begin(), vi.end(), p); // q 类似于first_free
	uninitialize_fill_n(q, vi.size(), 42);


## 移动构造和std::move

移动构造函数，通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。

move的标准库函数，定义在utility头文件中，调用move来表示希望使用（string的）移动构造函数，若是漏掉了move调用，将会使用（string的）拷贝构造函数。通常不为move提供一个using声明，而是直接调用std::move。


## 13.6 对象移动

提出对象移动的原因：
1. 对象拷贝后立即销毁；
2. IO类后unique_ptr这样的类，资源不共享

右值引用： 只能绑定到一个将要销毁的对象，从该对象“窃取”状态，不能直接绑定到一个左值上。一个右值引用也不过是某个对象的另一个名字而已，一个右值引用其本身是一个变量，即是左值。即右值引用不能绑定右值引用变量，但可以通过move获得一个绑定到左值上的右值引用。
int &&rr1 = 42;
int &&rr3 = std::move(rr1); // rr3获得了rr1的右值引用。move告诉编译器，我们有一个左值，但我们希望像一个右值一样处理它。使用std::move而不使用move可以避免潜在的名字冲突。

右值引用和左值引用的区别：
1. 右值引用就是必须绑定到右值的引用，通过&&获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。
2. 左值引用就是常规的引用，不能绑定到要转换的表达式、字面常量或返回右值的表达式，而右值引用恰好相反，可绑定到这类表达式，但不能绑定到一个左值上。
3. 返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符；返回右值的表达式包括返回非引用类型的函数及算术、关系、位和后置递增/递减运算符。可以看出左值的特点是有持久性，而右值则是短暂性。

左值持久；右值短暂： 


知道noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。
当移动构造函数和移动赋值操作符标记位noexcept，说明它们是安全的，那么就显示地告诉标准库（如vector）我们的移动构造函数可以安全使用的。vector必须知道元素类型的移动构造函数是安全的不会抛出异常，否则在重新分配内存的过程中，就必须使用拷贝构造函数而不是移动构造函数。

在移动操作之后，移后源对象必须保持有效的、可析构的状体，但是用户不能对其值进行任何假设。

只有当一个类没有定义任何自己版本的拷贝控制成员（构造函数、拷贝构造函数和析构函数），且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。

移动右值，拷贝左值

更新三/五法则：所有五个拷贝控制成员应该看作一个整体，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。


与任何赋值运算符一样，移动赋值运算符必须销毁左侧运算对象的旧对象。

移动迭代器适配器
调用标准库的make_move_iterator函数将一个普通迭代器转化为一个移动迭代器，移动迭代器的解引用运算符生成一个右值引用，而普通迭代器的解引用运算符返回一个指向元素的左值。那么可以猜测内部使用了std::move操作。

在类代码中小心地使用move，可以大幅提升性能。而如果杂普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名奇妙的、难以排查的错误，而难以提升应用程序性能。

在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std::move

## 右值引用和成员函数
构造函数和赋值运算符：一个是拷贝版本一个是移动版本，参数分别是接受一个指向const的左值引用，另一个接受一个指向非const的右值引用，则能够从中收益。

区别移动和拷贝的重载函数通常有一个版本接受一个const T&,另一个版本接受一个T&&。

std::allocator<string> alloc_;
void push_back(string s) {
 alloc_.construct(first_free_++, std::move(s));
}
函数使用第二个实参类型来确定使用哪一个构造函数，构造函数有第一个指针所指向的对象来决定。

右值和左值引用成员函数:C++11新标准库类仍然允许向右值赋值，若是希望自己的类阻止这种用法，可在参数类表后放置一个“引用限定符”，表示只能向可修改的左值赋值。 引用限定符可以是&和&&，分别指出this可以指向一个左值或右值，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。


如果一个成员函数有引用限定符，则相同参数列表的所有版本都必须有引用限定符。引用限定符的目的是为了指出this的左值/右值属性

