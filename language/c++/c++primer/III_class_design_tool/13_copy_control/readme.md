## 拷贝控制操作

一个类通过5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁时做什么

1. 拷贝构造函数
需要拷贝操作的类也需要赋值操作，反之亦然。（例如：一个类为每个对象分配一个独有的、唯一的序号），都不必然需要析构函数。使用一个static成员为每个非静态的数据成员赋值，而每次发生拷贝构造或拷贝赋值时，先将static类成员变量加1，并赋值给非static成员变量，保证了每个类对象有唯一的一个标号。

2. 拷贝赋值运算符

重载运算符本质上是函数，其名字由operator关键字接表示要定义的运算符的符号组成，因此，赋值运算符就是一个名为operator=的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。

重载运算符的参数表示运算符的运算对象。


赋值运算符必须定义为成员函数，如果一个运算符是成员函数，其左侧运算对象就绑定到隐式的this参数。标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

3. 移动构造函数

4. 移动赋值运算符

5. 析构函数

析构函数的名字由波浪号接类名构成，没有返回值也不接受参数，因此它不能被重载。

析构函数首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。

析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。

需要析构函数的类也需要拷贝和赋值操作。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求要更明显。如果一个类需要析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值操作运算符




## 为什么要使用资源管理类呢？

1. 栈内存有限，需要使用堆内存，而堆内存理论上可以达到pow(2, 32)或pow(2, 64);

2. 使用资源管理类时，一般使用swap交换操作，可作为资源类的友元函数，而在拷贝赋值操作符中使用值传递，这样就实现了拷贝赋值操作符中使用了拷贝构造函数，以及自己的swap操作，而自己的swap操作中，可以使用std::swap，这样就得到了STL的加持，也考虑到了自赋值的情况，同时保证了异常安全性，即在调用拷贝构造函数时因为new而抛出异常的话，不会影响左侧对象原有的数据，因为抛出异常后，程序员进行了异常捕获（在使用构造函数时）。注意只有类值版本可以使用swap，而类指针版本不能够使用swap版本，因为类指针版本有引用计数，不能进行简单的交换。



当类要利用sort函数进行排序时，需要有两个函数，分别是`operator<` 和swap函数。在sort时需要交换数据，这个时候就需要进行swap交换数据。类指针的HasPtr版本也可以从swap函数受益。


## 拷贝控制示例

通常分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因，还有一些类也需要拷贝控制成员的帮助来进行薄记工作或其他操作。


通过swap可以避免对标准库容器成员的不必要拷贝，例如有个类，它有stl的成员，那么在实现拷贝赋值操作符时，利用自定义的swap可以将对stl容器成员进行std::swap处理，同时对特定的数据进行交换。

std::allocator<T> 就是一个内存管理的工具类，表现为内存分配和对象构造，对象析构和内存释放。根据不同的T生成相应对象的内存申请工具，通过allocate(n)，表示分配n块T的内存，返回内存首地址。

allocator<T> a;
auto p = a.allocate(n); // 分配n块T对象的内存
a.deallocate(p,n); // 释放从p开始的内存，共有n个类型为T的对象。

a.construct(p, args); // p必须为一个类型为T*的指针，arg被传递给类型为T的构造函数
a.destroy(p); // 对p指向的对象执行析构函数

allocator算法，这些函数在给定目的位置创建元素，而不是由系统分配内存给它们：
uninitialized_copy(b, e, b2);

uninitialized_copy_n(b, n, b2);

uninitialized_fill(b, e, t);

uninitialized_fill_n(b, n, t);

eg:  

	auto p = alloc.allocate(vi.size() * 2);
	auto q = uninitialized_copy(vi.begin(), vi.end(), p); // q 类似于first_free
	uninitialize_fill_n(q, vi.size(), 42);


## 移动构造和std::move

移动构造函数，通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。

move的标准库函数，定义在utility头文件中，调用move来表示希望使用（string的）移动构造函数，若是漏掉了move调用，将会使用（string的）拷贝构造函数。通常不为move提供一个using声明，而是直接调用std::move。

