## 15.7.3 派生类的拷贝控制成员

派生类发生控制操作时，其基类部分也要做相对应行为的处理。析构函数除外，因为对象的成员是被隐式销毁的。

定义派生类的拷贝或移动构造函数，通常也要使用对应的基类的构造函数初始化对象的基类部分。

	class B {};
	class D : public B {
	 public:
	  D(const D& d) : Base(d) {}
	  D(D&& d) : Base(std::move(d)) {}
	  D& operator=(const D& rhs) {
	    if (&d == this)
		  return *this;

		Base::operator=(rhs);
	  
	  }
	};


### 15.7.4 继承的构造函数

为继承类的编写带来了某大的方便，在派生类中使用using Base::Base; 将完全继承基类的构造函数。若自身由成员变量，将被默认初始化。若基类中由默认实参，这个实参并不会继承。相反，派生类将获得多个继承的构造函数。其中每个构造函数分别省略掉一个含有默认实参的形参。
但是有两个例外：1.派生类可以覆盖 2.不继承基类默认、拷贝、移动构造函数

### 15.8
对于C++面向对象的编程来说，一个悖论就是我们无法直接使用对象进行面向对象编程，我们必须使用指针或引用。
