当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显示）参数数量比运算对象的数量少一个。
对于一个运算符函数来说，它或者是类的成员函数，或者至少含有一个类类型的参数。
对于一个重载的运算符来说，其优先级和结合绿与对应的内置运算符保持一致。
不能被重载的运算符有：
::   .*    .    ?:
通常情况下下面的四种运算符不应该被重载：&& || ， &  
逻辑与运算符(&&)和逻辑或运算符(||): 因为使用运算符函数本质上是一次函数调用，不能保留内置运算符的短路求值属性
逗号运算符(,)和取地址运算符(&)：C++已经定义了它们可用于类类型对象时的含义

重载的运算符最终都是对类的成员变量进行操作


当开始设计一个类时，首先应该考虑这个类将提供哪些操作。在确定需要哪些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符。

重载的运算符应该继承而非违背其内置版本的含义。

选择作为成员或非成员的标准：
强关系的作为成员，对称性的作为普通的非成员函数，如下：
	成员函数：=(赋值和复合赋值运算符),[],(),->, ++, --, &
	非成员函数：* / %  + -  > >= < <=  == != & ^ |   算术、关系、相等和位运算符

赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用。

重载的输入和输出运算符是针对类的成员变量进行输入和输出的。凡是对类的成员变量进行输出的，就可以使用operator<<，凡是需要对类的成员变量进行输入的，就可以使用operator>>运算符。
输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。输出和输入运算符必须是非成员函数，否则它们的左侧运算对象将是我们的类的一个对象。输入运算符必须考虑可能失败的情况，而输出运算符不需要考虑。

输入时的错误有：1. 流含有错误的类型 2.读取操作到达文件末尾或遇到输入流的其他错误。当读取操作发生错误时，重载的输入运算符应该负责从错误中恢复，可以取一个默认的对象值。输入运算符通常需要判断收入数据的正确性。

赋值运算符必须是成员函数
下标运算符，必须定义两个版本，一个返回普通引用，另一个是类的常量成员并且返回常量引用。
在迭代器类中通常需要实现递增和递减运算符(++和--)，应该同时定义前置版本和后置版本。前置版本返回对象的引用。递增运算符首先需要检测对象是否有效，再检查给定的索引是否有效。若是无效的话，就抛出异常。改变内部成员变量的索引值。而递减运算符是先递减索引值，然后再验证有效性。因为当索引值已经是0了，再递减的话，就会表示一个无效的索引值，若是unsigned的类型，那会将索引变成一个非常大的正数值。

区分前置和后置运算符：前置和后置的运算符是同一个符号，相同的参数，为了区别，后置版本接受一个额外的（不被使用）的int类型的形参。当使用这个后置运算符时，编译器为这个形参提供一个值为0的实参。其唯一的作用就是区分前置和后置版本的函数，而不是真的要在实现后置版本时参与运算。同时，后置版本返回的形式是一个值而非引用，返回的是对象的原值。

    StrBlobPtr StrBlobPtr::operator--(int) { 
      auto ret = *this; 
      --*this; // --和*都是第三优先级，且是向右结合运算对象。那么就是*先结合运算对象，之后再用--。由此可知，用前置运算符参与完成后置运算符的工作
      return ret; 
    }

前置运算符需要先检查后++，后置运算符先减后检查。它们返回的都是对象的引用

指针的算术运算符，最终是为了获得算术运算符之后的值，返回的是对象是值还是引用？不管是值还是引用，内部的值索引都需要改变，那么就是成员函数，可通过相应的符合算术运算符来完成，同时返回的对象是引用的形式，确保可以获得变化后的值内容。可以还可以对内容进行修改。
