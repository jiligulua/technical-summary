当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显示）参数数量比运算对象的数量少一个。
对于一个运算符函数来说，它或者是类的成员函数，或者至少含有一个类类型的参数。
对于一个重载的运算符来说，其优先级和结合绿与对应的内置运算符保持一致。
不能被重载的运算符有：
::   .*    .    ?:
通常情况下下面的四种运算符不应该被重载：&& || ， &  
逻辑与运算符(&&)和逻辑或运算符(||): 因为使用运算符函数本质上是一次函数调用，不能保留内置运算符的短路求值属性
逗号运算符(,)和取地址运算符(&)：C++已经定义了它们可用于类类型对象时的含义

重载的运算符最终都是对类的成员变量进行操作


当开始设计一个类时，首先应该考虑这个类将提供哪些操作。在确定需要哪些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符。

重载的运算符应该继承而非违背其内置版本的含义。

选择作为成员或非成员的标准：
强关系的作为成员，对称性的作为普通的非成员函数，如下：
	成员函数：=(赋值和复合赋值运算符),[],(),->, ++, --, &
	非成员函数：* / %  + -  > >= < <=  == != & ^ |   算术、关系、相等和位运算符

赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用。

重载的输入和输出运算符是针对类的成员变量进行输入和输出的。凡是对类的成员变量进行输出的，就可以使用operator<<，凡是需要对类的成员变量进行输入的，就可以使用operator>>运算符。
输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。输出和输入运算符必须是非成员函数，否则它们的左侧运算对象将是我们的类的一个对象。输入运算符必须考虑可能失败的情况，而输出运算符不需要考虑。

输入时的错误有：1. 流含有错误的类型 2.读取操作到达文件末尾或遇到输入流的其他错误。当读取操作发生错误时，重载的输入运算符应该负责从错误中恢复，可以取一个默认的对象值。输入运算符通常需要判断收入数据的正确性。

赋值运算符必须是成员函数
下标运算符，必须定义两个版本，一个返回普通引用，另一个是类的常量成员并且返回常量引用。
在迭代器类中通常需要实现递增和递减运算符(++和--)，应该同时定义前置版本和后置版本。前置版本返回对象的引用。递增运算符首先需要检测对象是否有效，再检查给定的索引是否有效。若是无效的话，就抛出异常。改变内部成员变量的索引值。而递减运算符是先递减索引值，然后再验证有效性。因为当索引值已经是0了，再递减的话，就会表示一个无效的索引值，若是unsigned的类型，那会将索引变成一个非常大的正数值。

区分前置和后置运算符：前置和后置的运算符是同一个符号，相同的参数，为了区别，后置版本接受一个额外的（不被使用）的int类型的形参。当使用这个后置运算符时，编译器为这个形参提供一个值为0的实参。其唯一的作用就是区分前置和后置版本的函数，而不是真的要在实现后置版本时参与运算。同时，后置版本返回的形式是一个值而非引用，返回的是对象的原值。

    StrBlobPtr StrBlobPtr::operator--(int) { 
      auto ret = *this; 
      --*this; // --和*都是第三优先级，且是向右结合运算对象。那么就是*先结合运算对象，之后再用--。由此可知，用前置运算符参与完成后置运算符的工作
      return ret; 
    }

前置运算符需要先检查后++，后置运算符先减后检查。它们返回的都是对象的引用

指针的算术运算符，最终是为了获得算术运算符之后的值，返回的是对象是值还是引用？不管是值还是引用，内部的值索引都需要改变，那么就是成员函数，可通过相应的符合算术运算符来完成，同时返回的对象是引用的形式，确保可以获得变化后的值内容。可以还可以对内容进行修改。


- 成员访问运算符

解引用运算符（*）和箭头运算符（->）:箭头运算符的实际工作委托给解引用运算符，都是const成员，获取一个元素并不会改变对象的状态， 而它们的返回值是非const的引用或指针。->:获取对象的成员（成员函数或成员变量）

- 函数调用运算符（必须是成员函数）

如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。调用对象实际上是在运行重载的调用运算符。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上由所区别。如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这个对象，就可以说这些对象的“行为像函数一样”。


什么情况下使用lambda，什么情况下使用函数对象？调用标准库算法时使用lambda，
当代码需要一个简单的函数，并且这个函数并不会在其他地方被使用，就可以使用lambda来实现，此时它的作用类似于匿名函数。如果这个函数需要多次使用，并且它需要保存某些状态的话，使用函数对象则更适合一些。

标准库定义的了一组表示算术运算符、关系运算符和逻辑运算符的tempalte类，每个类分别定义了一个执行命名操作的调用运算符。这些类型定义在functional头文件中。要在算法中使用标准库函数对象。

如：std::sort(svec.begin(), svec.end(), std::greater<string>()); // std::greater<string>表示类型，而()表示定义了一个未命名的对象。该函数负责在string元素之间执行>比较运算。
关联容器使用less<key_type>对元素排序，因此我们可以定义一个指针的set或在map中使用指针作为关键值而无须直接声明less。

可以使用特殊的functional adapter（函数适配器），或所谓binder，即将预定义的函数对象和其他数值结合为一体。

可调用对象与function：
C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、重载了函数调用运算符的类、bind创建的对象。可调用对象也有类型，每个lambda有它自己唯一的未命名的类类型。两个不同类型的可调用对象却可共享同一种 **调用形式**  ，调用形式指明了调用返回的类型以及传递给调用的实参类型。

不同类型可能具有相同的调用形式，注意是调用的形式即调用签名（call signature），但类型是不同的。
为了解决这个问题，新的标准库提供了function类型，可用来存储可调用对象，模板类型为对象的可调用形式。那么就可以保存可调用的对象啦。function收集可调用对象，并统一处理。function类型重载了调用运算符，该运算符接受它自己的实参，然后再将其传递给存好的可调用对象。不能（直接）将重载函数的名字存入到function类型的对象中，二是存储函数的指针，如：

		int add(int i, int j) { return i+j; }
		int (*fp)(int, int) = add;
		binops.insert({"+", fp});  // 此处为函数的指针，若是binops.insert({"+", add}); 是错误的。但是定义并初始化的时候是可以的，如

		function<int(int, int)> f1 = add;

同样也可以使用lambda来指定我们希望使用的add版本，如：

		binops.insert({"+", [](int a, int b) { return a+b; }});

## 、重载、类型转换和运算符

类型转换运算符是类的一个特殊的成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：

		operator type() const;

类型转换运算符可以面向任意类型（除void之外）进行定义，只要该类型能作为函数的返回类型，因此不允许转换成数组或函数类型，但允许转换成指针（包括数组指针及函数指针）或引用类型。类型转换函数不能声明返回类型，形参列表也必须为空，类型转换函数通常是const。

和使用重载运算符一样，明智地使用类型转换运算符能极大地简化类设计者的工作，同时使用类更加容易。然而，如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。但在实际类中很少用，一般定义bool的类型转换还是比较普遍的现象。C++11新版本引入显示的类型转换运算符(explict conversion operator)来避免异常情况发生。和显示的构造函数一样，编译器通常也不会将一个显示的类型转换运算符用于隐式类型转换。需要通过static_cast来转换。该规定有一个例外，即如果表达式用作条件，编译器会将显示的类型转换自动应用它，即显示的类型转换将被隐式地执行：

- if,while, do的条件部分；
- for语句头的条件部分；
- 逻辑非运算符！，逻辑与运算符&&，逻辑或运算符||的运算对象；
- 三目条件运算符？：的条件表达式；

向bool的类型转换通常用在条件部分，因此operator bool 一般定义为explicit。

类型转换运算符定义的一个经验是：类的数据成员只有一个，若是有多个的话，需要把多个成员变量放在一起才算是有效的数据。类从某种角度来讲，就是将数据作用到一些操作上。

使用类型转换运算符是有意在条件表达式中使用，所以需要explicit operator bool() const { return ... && ...; }
也就是说但凡这个可以用在条件表达式中，就可以使用显示地定义bool类型转换运算符，以达到设计高效类的目的。

通常情况下，不要为类定义相同地类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型地转换。

有两种情况可以产生多重转换路径，就会有二义性的可能，如下：
1. 当A类定义一个接受一个B类对象的转换构造函数；
2. B类定义一个转换目标是A类的类型转换运算符；
若不得不执行，就需要显示地调用类型转换运算符或者转换构造函数。
		
		class A {
		 public:
		  A() = default;
		  A(const B&);
		};

		struct B {
		  operator A() const;
		};
		
		A f(const A&);
		B b;
		A a = f(b); // 编译器无法辨认

		A a1 = f(b.operator A());
		A a2 = f(A(b));


最好不要创建两个转换源（即构造函数中的参数）或转换对象（类型转换运算符的转换目的对象）都是算术类型的类型转换。

要想正确地设计类的 **重载运算符**、 **转换构造函数** 和 **类型转换函数**，必须加倍小心。

一言以蔽之：除了显示地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显示构造函数。

标准类型转化：如int->long

### 函数匹配与重载运算符

重载的运算符也是重载地函数，和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。

当我们使用重载运算符作用于类类型的运算对象时，候选函数中包括该运算符的普通非成员函数版本和内置版本。

表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数。试图执行混合模式的算术运算，就将遇到二义性。

## 小结

在类中可以定义转换源或转换目的是该类型本身的类型转换，这样地类型转换将自动执行。只接受单独一个实参的非显示构造函数定义了从实参类型到类类型的类型转换；而非显示的类型转换运算符则定义了从类类型到其他类型的转换。

类类型转换有两种方法：由构造函数定义的从其他类型到类类型地转换，由类型转换运算符定义的从类类型到其他类型的转换。

