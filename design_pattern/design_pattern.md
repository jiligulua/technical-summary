## 0 技术和艺术

编程是一门技术，更加是一门艺术。

继承：用空心三角形+实线来表示。
依赖：用虚线+箭头表示（如：动物依赖氧气和水，不能离开它们）。
关联：当一个类“知道”另一个类时，可以用关联，用实现+箭头表示。如企鹅关联气候，即在企鹅中引用到了天气对象。
聚合：表示一种弱“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象地一部分。用空心菱形+实现表示，没有很明确的1对几的基数关系（如雁群和大雁的关系）。
合成（组合）：表示一种强“有用”关系，体现了严格的部分与整体关系，部分和整体的生命周期一样。用实心菱形+实现表示，有很明确的1对几的基数关系（如鸟和翅膀的关系）。

## 1 单例模式

Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。该类自身负责保存它的唯一实例，这个类保证没有其它实例可以被创建，实现对唯一实例的受控访问。

饿汉式单例类：静态初始化的方式是在自己被加载时就将自己实例化；
懒汉式单例类：在第一次被引用时，才会将自己实例化；当面临多线程访问的安全问题时，需要做双重锁定才可保证安全。（Java，那C++中是否也一样）

我们应该把所有应用都考虑为多线程，并提供双重检查加锁实现。(Java, C++中没有看到)


## 2 观察者模式

### 来自《大话设计模式》

避免双向耦合，首先是开发-封闭原则，其次是依赖倒转原则，应该让程序都依赖抽象，而不是相互依赖。观察者的更新行为不同，所以要将更新行为抽象出来。
前台也好，老板也好，其实都是具体的通知者（Subject）。看股票的观察者（Observer）不应该依赖具体的实现，而是一个抽象的通知者。
当通知者状态改变时，就需要执行通知者的接口Notify，以便可以挨个通知观察者去做相应的Update行为（如：关闭股票软件）。

观察者模式又叫做发布-订阅（Publish/Subscribe）模式：
Observer：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

Subject类可译为主题或通知者。
Subject类，抽象主题把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供增加和删除观察者对象的接口。（Attach,Detach,Notify）
Observer类，抽象观察者为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。(Update)
ConcreteSubject类，具体主题将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题通常用一个具体的子类实现。
ConcreteObserver类，具体观察者，实现更新接口，以便使本身的状态与主题的状态相协调。具体观察者可以保存一个指向具体主题对象的引用，以便知道具体主题对象的状态。

用观察者模式的动机：
将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象的一致性。但有不希望为了维护一致性而使各个类紧密耦合，这样会给维护、扩展和重用都带来不便。
观察者模式所作的工作其实就是在解除耦合。让耦合的双方都依赖与抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化，是 **依赖倒转原则** 的最佳体现。

什么时候考虑使用观察者模式：当一个对象的改变需要同时改变其它对象，而且不知道具体有多少对象有待改变时。

若是“抽象通知者”不依赖“抽象观察者”，那怎么办呢？用委托机制，在.net中，如声明一个委托：delegate void EventHandler(事件处理程序，拿C++来说就是函数指针); 就是将观察者的各自不同名字的响应接口委托给EventHandler来执行,而在通知者中定义一个EentHandler的一个变量。如huhansan.Update += New EventHandler(tongshi1.CloseStockMarke);

委托可以看作是对函数的抽象，是函数的类，拿C++来说就是可调用对象（分函数、函数指针、lambda表达式、函数对象和bind所构成的函数）。这个委托特别像C++中的function<int(int,int)>模板函数，而事件就是不同类中有相同可调用形式的函数。

点击“运行”时，所谓的“工具箱隐藏”、“错误列表隐藏”、“窗口自动打开”、“命令窗口打开”不过就是在“运行”时注册的四个事件的触发而已。别说是4个，40个完全不同的控件都可以通知到。趣闻：石守吉失手机后的委托趣闻

### 来自《HeadFirst》

HeadFirst: 案例是气象检测应用，出版社+订阅者=观察者模式，我们把出版社叫作主题（Subject），把订阅者叫作观察者（Observer）。主题对象管理某些重要数据，当主题内的数据改变就会通知观察者，观察者已经订阅（注册）该主题，以便在主题数据改变时收到更新。
软件开发的不变因素就是变化

**观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。**

观察者模式有几种不同的实现方式，但大多数围绕者包括主题和观察者接口的类设计。

主题是数据（或状态）的唯一拥有者，观察者是主题的依赖者，观察者只能使用这些数据的状态，观察者依赖主题告知它们状态发生了改变。这比起许多对象控制同一份数据来说，可以得到更干净的OO设计。

报纸订阅及出版者和订阅者，是形象化观察者模式的一种好的方式。出版-订阅模式并不是观察者模式，它比观察者模式复杂，它允许订阅者对不同类型的消息感兴趣，并进一步分离出版者和订阅者，这个模式常用于中间件系统。

就像编织不那么紧密的篮子，松耦合让系统更具弹性，更善于处理变化。当两个对象松耦合时，它们可以交互，但是通常对彼此所之甚少，而观察者模式是松耦合的一个很棒的例子。

设计原则：尽量做到交互的对象之间的松耦合设计。松耦合设计允许我们建造能够应对变化的，有弹性的OO系统，因为对象之间的互相依赖降到最低。

为什么要保存对WeatherData主题的引用？为将来取消观察者的注册带来方便。在其它地方观察者也被称呼为Listener（监听器）。

在许多情况下，让Observer检索它们需要的数据，而不是通过Update()方法传递越来越多的数据给它们，是有道理的。此时，notifyObservers方法，不带参数地调用Observer中的Update()方法，并在Update()方法中通过Subject的引用来pull数据。即使用该模式时，可以从主题推或拉数据（拉被认为更“正确”）。

出版/订阅模式用于更复杂得多主题或/和多消息类型的情形，在学习模型-视图-控制器时，还会看到观察者模式。

#### 设计原则

1. 识别应用中会变化的方面，并将其和不变的方面分离；在观察模式中，改变的的是主题的状态，以及观察者的数目和类型。有了这个模式，我可以改变依赖于主题状态的对象，却不必改变主题，就叫作提前规划。
2. 针对接口编程，而不是针对实现；主题和观察者都使用接口，主题跟踪实现观察者接口的对象，而观察者通过主题接口注册并被通知，实现松耦合。
3. 优先使用组合而不是继承；观察者模式使用“组合”来将任意数量的观察者组合进主题，这种关系不是由某种继承层次设置，而是组合设置。

### 来自《深入应用C++11代码优化及工业级应用》

C++11之前观察者模式中对观察者的限制
1. 需要继承，继承是强对象关系，不够灵活；
2. 观察者被通知的接口参数不支持变化，导致观察者不能应付接口的变化；
C++11改进：
1. 通过被通知接口参数化和std::function来代替继承；
2. 通过可变参数模板和完美转发来消除接口变化产生的影响。
改进后的观察者，通过定义委托类型来限定观察者，不要求观察者必须从某个类派生，当需要增加和原来不同的观察者时，只需要定义一个新的event类型即可，通过event可以方便地增加或移除观察者。如果希望这个event类不可复制，可以实现一个NonCopyable，使用C++11的default和delete特性。

C++11实现的观察者模式，内部维护了一个泛型函数列表，观察者只需要将观察者函数注册即可，消除了继承导致的强耦合。通知接口使用了可变参数模板，支持任意参数，消除了接口变化的影响。

## 3 访问者模式

### 来自《大话设计模式》

人类只分男人和女人，混在一起学习。所谓的成功、失败或恋爱都是指人的一个状态，是一个属性。成功时如何、失败时如何不过是一个反应。提炼出‘状态’的抽象类（获得不同类的结论或反应）和‘人’的抽象类（接受‘状态’对象，即visitor），用到双分派技术，意味着得到执行的操作决定于请求的种类和两个接受者的类型。‘接受’方法就是一个双分派的操作，它得到执行的操作不仅决定于‘状态’类的具体状态，还决定于它访问的‘人’的类别。若是增加‘结婚’的状态来考查‘男人’和‘女人’，由于用到了双分派，只需要增加一个‘状态’子类，只需要在客户端调用查看，而不需要改动其它任何类的代码。完美体现开发-封闭原则，应该是GoF中作复杂的一个模式，叫访问者模式。

Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作，在不改变各元素的类的前提下定义作用于这些元素的新操作。

(新操作就是新的状态以及相应的的反应，而这个状态定义为一个访问类，去访问对象结构中的各个元素，而这些不同的元素可以访问不同的访问类所提供的接口即反应，因为不同元素在相同状态下的反应是不同的，即需要访问不同的元素)。男女对比这么多的原因是因为人类在性别上就只有男人和女人两类，这正是访问者模式可以实施的前提，这样‘状态’类抽象的方法就稳定。

Tips：也就是说，访问者模式适用于数据结构（此处可理解为对象结构，这个数据就是结构中的元素）相对稳定的系统，它将对象结构和作用于结构上的操作解耦，使得操作集合可以相对自由地演化。这样就是把处理从对象结构中分离出来，这样算法操作要增加时就会变得容易。反之，若对象结构不稳定，则不适合使用访问者模式。优点就是增加新的操作很容易，增加新的操作就是增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。缺点也很明显，就是增加新的对象结构变地困难了。 ObjectStructure有很多Element，它们有共同的Accept接口(用Visitor作为参数)，在函数体中，Visitor变量根据当前不同的Element访问对应的不同元素的行文。

只有当我真正需要访问者模式时，才考虑使用它。为啥作者说，男人和女人的最大区别是比上不足比下有余？

### 来自《HeadFirst》

当我想要为一个对象组合增加能力，且封装不重要时，使用访问者模式。

### 来自《深入应用C++11》

在访问模式中被访问者应该时一个稳定的继承体系，如果这个继承体系经常变化，就会导致经常修改Visotor的基类，因为在Visitor基类中定义了需要访问的对象类型，每增加一种访问类型就要增加一个对应的纯虚函数。而访问者模式的接口不太稳定，会导致整个系统不稳定，最根本的解决方法就是定义一个稳定的Visitor接口层，即不会因为增加新的被访问者而修改接口层。通过C++11进行改进，可以实现这个目标。

通过可变参数模板可以实现一个稳定的接口层，利用可变参数模板可以支持任意个参数的特点，让访问者接口层访问任意个数的被访问者，这样就不需要每增加一个新的被访问者就修改接口层，从而使接口层保持稳定。

/*
   struct和class的区别：
   从语法上来讲，它们作类型时只有两点区别：
   1. 默认继承权限：如不明确指定，来自class的继承安置private继承处理，来自struct的继承安置public继承处理；
   2. 默认访问权限：class的成员默认private权限，struct默认public权限；
 */

