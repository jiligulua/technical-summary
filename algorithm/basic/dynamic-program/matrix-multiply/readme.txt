特征
1.最优子结构
2.重叠子问题

构建动态规划的一般步骤：

1.描述最优解的结构

在矩阵链相乘中，在具体的A1A2A3...An中，可以抽象出Ai...Aj的矩阵链，1 <= i < j <= n，这是一个很重要的突破口，也是第一层抽象。就是从具体的起始点和终点抽象出中间的两个点，而两个点i和j的变动，就会覆盖所有1到n的过程。一定要明确，这是一个动态变化的过程。


那么，当添加一个全括号时，就会在i和j之间，分隔开来从而形成两个部分，假如最优子结构是（i，k），那么（i，j）中由k分隔开来的另一部分也是（k+1，j）必然也是最优子结构。由反证法可知，若还有最优的子结构，那么（i，k）就不是最优子结构，与最初的假设矛盾。从这个子结构出发，可定义出递归公式。



2.描述最优解的递归定义

由于要明确递归的含义，首先要明确我们的最终目的，就是获得最高的运行效率，也就意味着获取Ai...Aj相乘的最小时间复杂度，那么可以定义出，Ai...Aj的最小运行次数m[i][j]。（一般动态规划都用一维或二维表达），那么就可以推导出，当由最优子结构时，就是由m[i][k]+m[k+1][j]两部分组成，以及它们相乘时的运行次数，为pi-1 * pk * pj，那么递归公式为：
矩阵相乘，其运行时间效率是不同。而运行时间的效率，主要体现在指令的执行次数。比如两个矩阵A（p*q）和B（q*r），那么矩阵相乘的时间效率就是：p*q*r,即T（A*B）= p*q*r。

由于p、q和r的不同，自然会导致不同的量级。

m[i][j] = m[i][k] + m[k+1][j] + pi-1 * pk * pj    (1 <= i < j <= n)
		= 0 (i == j, 此时没有矩阵进行相乘，也就没有运行次数，故为0,同时也看到了没有和自己相乘的情况，因为我们都是从一个链在相乘，所以，此时必为0）



既然有了递归定义，那么就可以从下往上来进行求解问题。由于题干中没有给出具体的维度，那么就需要自己来定义数据结构，主要的函数变量就是矩阵个数已经各个矩阵的维度。矩阵个数可以直接使用变量n来替代，而矩阵维度一维数组表示d[n+1]，因为有n个矩阵，所有有n个行数，这就有n个数据了，其中n个行中已有n-1个列数，只有最后一个矩阵的列数不知道，就是还需要再加一个数，构成n+1个数据。同时，为了获得最小运行次数，需要记录i和j之间获取的最小运行次数和对应的k值。

n表示矩阵链中的矩阵个数
d[n+1]表示d[i]表示Ai的行数，列数有d[i+1]表示
m[i][j]存放最小运行次数

s[i][j]存放最小运行次数时的全括号k值，最终需要的就是这个值！
它表示在（i，j）之间用分隔值k，得到（i，k）和（k+1，j）两个分组。
那么在s[1,n]之间，应该也是存在k值，使得分隔方案为：（1，k）和（k+1，n），然后在各自的（1，k）和（k+1，n）之间，继续寻找分隔点，以此类推，直到不能再分隔为止，那么，这个时候又是一种什么状态呢？这个时候，就是输出对应的矩阵节点值。

那如何输出这个s呢？

参考：https://blog.csdn.net/weixin_51472145/article/details/123943970

