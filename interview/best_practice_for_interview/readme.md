- 封装

在面向对象编程里面，把数据和针对该数据的操作，统一在一个class里面。增加代码内聚性，进而提高可复用性、可维护性，还可以“信息隐藏”，用public、proected和private实现控制。
还有的其它手段有：

1. 通过文件统一信息；
2. 通过namespace统一信息；

struct和class的区别：
C++中struct和class意义一样，唯一不同的是各自默认的访问和继承控制不同，前者默认是public，后者默认是private。存在的唯一意义是为了让C程序员有归属感，为了让C++编译器兼容以前用C开发的项目。

在同一个类的实例之间共享，必须使用静态成员变量。若是要设置访问类型，必须是protected或private，不允许静态成员变量存放某一个对象的数据，它为类的所有对象共享。
若要访问静态成员变量的值，通过public的静态成员函数访问。特别注意，静态成员变量必须赋初值（即初始化）。

初始化列表的初始化变量顺序是根据成员变量的声明顺序来执行的。
常量必须在构造函数的初始化列表里面初始化或将其设置为static。(在C++11中已正确，可以直接在类中声明)

为什么基类析构函数需要声明为虚拟的？因为存在多态。当派生类的指针赋值给基类指针后，析构该指针时，就会先调用派生类的析构函数，再调用基类的析构函数。若不声明虚拟的析构函数，则当派生类指针指向基类指针并在析构该指针时，仅调用基类的析构函数，不调用派生类的析构函数，存在内存泄漏的隐患。即若派生类的构造函数在堆中分配内存，就会造成内存泄漏。若只是在栈中，则不会有什么大问题。
若基类的析构函数声明为Virtual函数，则派生类的析构函数自动声明为Virtual，保证任何情况下，派生类的析构函数都能被调用，不会造成资源泄漏。

构造函数为什么不能是virtual函数，因为virtual（虚）调用是一种只知道接口而不知道准确对象类型的函数，而创建一个对象，必须知道准确类型，因此构造函数不能为虚函数。

是否每个函数都可以声明为虚函数？虚函数是有代价的，每个虚函数的对象都必须维护一个v表，使用虚函数会产生一定系统开销。若是一个小类又不想派生其它类，就根本不需要使用虚函数。

构造函数可以是内联的

带参数的构造函数，冒号后面是成员变量初始化列表。如果带参数的构造函数只有一个参数，并且不声明explicit关键字，会产生一个隐式的类型转换。

拷贝构造函数中为何要用const修饰：1.若是非const，那么const变量无法执行拷贝构造函数，因为const无法转化为非const；2.用“+”赋值必须返回一个操作值已知的MyString对象，除非它是一个const对象？

member-wise copy(编译器逐个成员变量进行赋值) and bitwise copy（通过memcpy之类实现）

- 构造和析构顺序
1. 先构造基本，最后构造当前类；
2. 析构顺序相反，先析构当前类，最后析构基类；

- 介绍member-wise copy和bitwise copy区别？
1. 默认的是member-wise copy，即对基类和所有成员都分别进行copy；
2. 如果一个类的所有直接或间接基类、成员都没有自定义copy，那么member-wise copy就等价于bitwise copy(C的所有对象是POD，对象的二进制可以完美的赋值拷贝)；

为什么派生类的同名函数会屏幕父类的同名函数？因为派生类的作用域嵌套在父类的作用域中。
派生类中虚函数的声明必须与基类中定义方式完全匹配，但有一个例外，返回对基类的引用或指针的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。

- 什么是多态？
（开门、开窗户、开电视，这里的“开”就是多态）
简单地概括为“一个接口，多种方法”，在程序运行的过程中才决定调用的函数。多态的本质就是将子类类型的指针赋值给父类类型的指针（只要这样的赋值发生了，多态也就产生了，实行了“向上映射”），它是通过虚函数实现的。是面向对象编程领域的核心概念。

具体来讲，多态就是允许将父对象设置成和它的一个或多个子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特征以不同的方式运作。


- 重载和覆盖有什么不同？

重载（overload），是指编写一个与已有函数同名但参数表不同的函数。重载不是一个面向对象的编程，只是一种语法规则，重载和多态没有关系。
覆盖（override），是指派生类重写基类的虚函数，必须有一致的参数表和返回值（C++标准允许返回值不同的情况）

- 编译器解析？

宏、内联函数和模板在编译器解析，虚函数在运行期确定。

- 防止C++资源泄漏的方法？

资源获取就就是初始化（RAII），即对资源的初始化和析构成对出现，一个资源就是一个RAII

- 对象构建异常情况
1. 在C++中通知对象构造失败的唯一方法，就是在构造函数中抛出异常。
2. 对象的部分构造是很常见的，异常发生点也完全是随机的，要谨慎处理。
3. 当发生部分构造时，已经构造完毕的子对象会逆序地被析构，而还没有开始构建地子对象将不会被构造；还有正在构建的子对象和对象本身将停止构建，并且它的析构函数是不会被执行的。

## 继承与接口

- 虚函数接口调用

使用就近原则。若指明了调用某个类的虚函数接口，就调用该接口。若没有定义虚函数接口，父类存在相关接口则优先调用父类接口，若没有则调用祖父类接口。

一个私有的或保护的派生类不是子类，因为非公共的派生类不能做基类所做的所有事情。

派生类3种继承方式：公有继承、私有继承和保护继承。


每个对象里有一个虚表指针（vfptr），指向虚函数表，虚函数表里存放虚函数地址，虚函数表里是顺序存放虚函数地址的。

- 虚继承
虚继承是指一个指定的类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。说白了就是共享基类的数据！

当评价一个潜在的继承关系时，重要的因素是可替代性的行为，而不是子集。


虚指针或虚函数指针是一个虚函数的实现细节，带有虚函数的类的每个对象都有一个虚函数指针指向类的虚函数表。

虚函数的入口地址保存在vtable中的某一项中，而对象中的vptr指向vtable，再去寻找相应虚函数项，实现“动态联编”



## 友元函数

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或函数成为它的友元。友元声明只能出现在类定义的内部，它不是类的成员也不受它所在区域访问控制级别的约束。
友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明，若类的用户想调用友元函数，仍需要在友元声明之外专门对函数进行一次声明。为方便，函数声明与声明友元的类放在同一个头文件中

- 封装

是指保护类的成员不被随意访问的能力，实现了类的接口和实现的分离，被封装的类的具体实现可以随意改变，而无须调整用户级别的代码。

- 可变数据成员

mutable，即使在一个const对象内也能被修改

- 返回*this的成员函数

对于一个对象的连续操作，可以让函数返回*this。

- 从const成员函数返回*this
一个const成员函数，如果以引用的形式返回*this，那么它的返回类型将是常量引用。

- 友元

要想令某个成员函数作为友元，必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。

1. 在类A中声明类B的友元成员函数f时，类B必须先定义，同时声明函数f，应该还需要声明类A
2. 定义类A；
3. 定义类的成员函数f，因为f中需要使用A的成员变量，所以A需要先定义；
其实就是一个可见性的问题。

友元声明的作用是影响访问权限，它本身并非普通意义上的声明。需要在友元声明之前，该函数是可见的。即需要有该函数的声明。

## 类的作用域


- 名字查找与类的作用域
类的定义分两部分，编译器处理完类中的全部声明后才会处理成员函数的定义。函数体在类可见后才会被处理。这里是讲可见性的事情

查找顺序：函数体内，类作用域内，全局作用域。

类型的声明必须前置，而变量的声明必须在查找的作用域内

区分类的声明，类的定义和类的实现，以及类对象的声明（即声明一个变量）


- 构造函数初始值列表
成员是const或引用时，必须将其初始化
初始值列表用于初始化成员变量，而在构造函数体内是对成员变量进行赋值，而非初始化。
当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

即若果成员是const、引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值。
构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序；
成员的初始化顺序与它们在类定义中的出现顺序一致。

如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数

- 委托构造函数

只有一个构造函数的参数列表中的参数个数对应了类中的所有成员变量，而其他构造函数则委托给该构造函数初始化成员。

在定义了其它构造函数，那么最好也提供一个默认构造函数。这样的类在作为成员变量时，不会引起编译器出错。

## 隐式的类类型转换

只允许一步类类型转换，通过explicit可以阻止隐式类型转换，同时explicit构造函数只能用于直接初始化，而不能执行拷贝形式的初始化。这个使用，有两种办法可以作为函数调用的参数，一种是实参是显示构造的对象，通过类名(参数)，构造一个临时量，另一种方式是通过static_cast<类名>(参数)来构造类的临时对象，执行了显示的而非隐式的转换。
从参数类型转化为

## 聚合类
聚合，单纯从字面意思理解，就是将各个成员简单聚合在一起而已

1. 都是public 2. 没有构造函数 3. 没有类内初始值 4. 没有基类也没有virtual函数   这样的类就是聚合类，聚合类可以使用一个花括号提供成员初始值列表，并用它初始化聚合类的数据成员。保持声明和初始值的顺序一致性，若初始值少于声明的个数，后面的成员被值初始化。

## 字面值常量类
数据成员都是字面值类型的聚合类是字面值常量类，constexpr构造函数。一个字面值常量类必须提供一个cosntexpr构造函数。
常量类存在的意义在于提供都是常量的一个类，并且该类在编译的过程中可以产生多个不同数据成员的constexpr类对象.
数据成员都是字面值类型的聚合类是字面值常量类。只要是聚合类就是字面值常量类，因为它们都可以通过常量来进行初始化。

## 类的静态成员
静态成员于类关联，通过static使其与类关联在一起。
要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。静态成员、指针成员和数据成员，前两者可以是不完整类型，而后者必须是完整类型。即前两者可以在类中声明为它所属的类类型，而后者就不可以这么做。另一个是我可以使用静态成员作为默认实参。
