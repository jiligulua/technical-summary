## 封装

在面向对象编程里面，把数据和针对该数据的操作，统一在一个class里面。增加代码内聚性，进而提高可复用性、可维护性，还可以“信息隐藏”，用public、proected和private实现控制。
还有的其它手段有：

1. 通过文件统一信息；
2. 通过namespace统一信息；

struct和class的区别：
C++中struct和class意义一样，唯一不同的是各自默认的访问和继承控制不同，前者默认是public，后者默认是private。存在的唯一意义是为了让C程序员有归属感，为了让C++编译器兼容以前用C开发的项目。

在同一个类的实例之间共享，必须使用静态成员变量。若是要设置访问类型，必须是protected或private，不允许静态成员变量存放某一个对象的数据，它为类的所有对象共享。
若要访问静态成员变量的值，通过public的静态成员函数访问。特别注意，静态成员变量必须赋初值（即初始化）。

初始化列表的初始化变量顺序是根据成员变量的声明顺序来执行的。
常量必须在构造函数的初始化列表里面初始化或将其设置为static。(在C++11中已正确，可以直接在类中声明)

为什么基类析构函数需要声明为虚拟的？因为存在多态。当派生类的指针赋值给基类指针后，析构该指针时，就会先调用派生类的析构函数，再调用基类的析构函数。若不声明虚拟的析构函数，则当派生类指针指向基类指针并在析构该指针时，仅调用基类的析构函数，不调用派生类的析构函数，存在内存泄漏的隐患。即若派生类的构造函数在堆中分配内存，就会造成内存泄漏。若只是在栈中，则不会有什么大问题。
若基类的析构函数声明为Virtual函数，则派生类的析构函数自动声明为Virtual，保证任何情况下，派生类的析构函数都能被调用，不会造成资源泄漏。

构造函数为什么不能是virtual函数，因为virtual（虚）调用是一种只知道接口而不知道准确对象类型的函数，而创建一个对象，必须知道准确类型，因此构造函数不能为虚函数。

是否每个函数都可以声明为虚函数？虚函数是有代价的，每个虚函数的对象都必须维护一个v表，使用虚函数会产生一定系统开销。若是一个小类又不想派生其它类，就根本不需要使用虚函数。

构造函数可以是内联的

带参数的构造函数，冒号后面是成员变量初始化列表。如果带参数的构造函数只有一个参数，并且不声明explicit关键字，会产生一个隐式的类型转换。

拷贝构造函数中为何要用const修饰：1.若是非const，那么const变量无法执行拷贝构造函数，因为const无法转化为非const；2.用“+”赋值必须返回一个操作值已知的MyString对象，除非它是一个const对象？

member-wise copy(编译器逐个成员变量进行赋值) and bitwise copy（通过memcpy之类实现）

介绍member-wise copy和bitwise copy区别？
1. 默认的是member-wise copy，即对基类和所有成员都分别进行copy；
2. 如果一个类的所有直接或间接基类、成员都没有自定义copy，那么member-wise copy就等价于bitwise copy(C的所有对象是POD，对象的二进制可以完美的赋值拷贝)；
