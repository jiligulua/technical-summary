- 封装

在面向对象编程里面，把数据和针对该数据的操作，统一在一个class里面。增加代码内聚性，进而提高可复用性、可维护性，还可以“信息隐藏”，用public、proected和private实现控制。
还有的其它手段有：

1. 通过文件统一信息；
2. 通过namespace统一信息；

struct和class的区别：
C++中struct和class意义一样，唯一不同的是各自默认的访问和继承控制不同，前者默认是public，后者默认是private。存在的唯一意义是为了让C程序员有归属感，为了让C++编译器兼容以前用C开发的项目。

在同一个类的实例之间共享，必须使用静态成员变量。若是要设置访问类型，必须是protected或private，不允许静态成员变量存放某一个对象的数据，它为类的所有对象共享。
若要访问静态成员变量的值，通过public的静态成员函数访问。特别注意，静态成员变量必须赋初值（即初始化）。

初始化列表的初始化变量顺序是根据成员变量的声明顺序来执行的。
常量必须在构造函数的初始化列表里面初始化或将其设置为static。(在C++11中已正确，可以直接在类中声明)

为什么基类析构函数需要声明为虚拟的？因为存在多态。当派生类的指针赋值给基类指针后，析构该指针时，就会先调用派生类的析构函数，再调用基类的析构函数。若不声明虚拟的析构函数，则当派生类指针指向基类指针并在析构该指针时，仅调用基类的析构函数，不调用派生类的析构函数，存在内存泄漏的隐患。即若派生类的构造函数在堆中分配内存，就会造成内存泄漏。若只是在栈中，则不会有什么大问题。
若基类的析构函数声明为Virtual函数，则派生类的析构函数自动声明为Virtual，保证任何情况下，派生类的析构函数都能被调用，不会造成资源泄漏。

构造函数为什么不能是virtual函数，因为virtual（虚）调用是一种只知道接口而不知道准确对象类型的函数，而创建一个对象，必须知道准确类型，因此构造函数不能为虚函数。

是否每个函数都可以声明为虚函数？虚函数是有代价的，每个虚函数的对象都必须维护一个v表，使用虚函数会产生一定系统开销。若是一个小类又不想派生其它类，就根本不需要使用虚函数。

构造函数可以是内联的

带参数的构造函数，冒号后面是成员变量初始化列表。如果带参数的构造函数只有一个参数，并且不声明explicit关键字，会产生一个隐式的类型转换。

拷贝构造函数中为何要用const修饰：1.若是非const，那么const变量无法执行拷贝构造函数，因为const无法转化为非const；2.用“+”赋值必须返回一个操作值已知的MyString对象，除非它是一个const对象？

member-wise copy(编译器逐个成员变量进行赋值) and bitwise copy（通过memcpy之类实现）

- 构造和析构顺序
1. 先构造基本，最后构造当前类；
2. 析构顺序相反，先析构当前类，最后析构基类；

- 介绍member-wise copy和bitwise copy区别？
1. 默认的是member-wise copy，即对基类和所有成员都分别进行copy；
2. 如果一个类的所有直接或间接基类、成员都没有自定义copy，那么member-wise copy就等价于bitwise copy(C的所有对象是POD，对象的二进制可以完美的赋值拷贝)；

为什么派生类的同名函数会屏幕父类的同名函数？因为派生类的作用域嵌套在父类的作用域中。
派生类中虚函数的声明必须与基类中定义方式完全匹配，但有一个例外，返回对基类的引用或指针的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。

- 什么是多态？
（开门、开窗户、开电视，这里的“开”就是多态）
简单地概括为“一个接口，多种方法”，在程序运行的过程中才决定调用的函数。多态的本质就是将子类类型的指针赋值给父类类型的指针（只要这样的赋值发生了，多态也就产生了，实行了“向上映射”），它是通过虚函数实现的。是面向对象编程领域的核心概念。

具体来讲，多态就是允许将父对象设置成和它的一个或多个子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特征以不同的方式运作。


- 重载和覆盖有什么不同？

重载（overload），是指编写一个与已有函数同名但参数表不同的函数。重载不是一个面向对象的编程，只是一种语法规则，重载和多态没有关系。
覆盖（override），是指派生类重写基类的虚函数，必须有一致的参数表和返回值（C++标准允许返回值不同的情况）

- 编译器解析？

宏、内联函数和模板在编译器解析，虚函数在运行期确定。

- 防止C++资源泄漏的方法？

资源获取就就是初始化（RAII），即对资源的初始化和析构成对出现，一个资源就是一个RAII

- 对象构建异常情况
1. 在C++中通知对象构造失败的唯一方法，就是在构造函数中抛出异常。
2. 对象的部分构造是很常见的，异常发生点也完全是随机的，要谨慎处理。
3. 当发生部分构造时，已经构造完毕的子对象会逆序地被析构，而还没有开始构建地子对象将不会被构造；还有正在构建的子对象和对象本身将停止构建，并且它的析构函数是不会被执行的。

## 继承与接口

- 虚函数接口调用

使用就近原则。若指明了调用某个类的虚函数接口，就调用该接口。若没有定义虚函数接口，父类存在相关接口则优先调用父类接口，若没有则调用祖父类接口。

一个私有的或保护的派生类不是子类，因为非公共的派生类不能做基类所做的所有事情。

派生类3种继承方式：公有继承、私有继承和保护继承。


每个对象里有一个虚表指针（vfptr），指向虚函数表，虚函数表里存放虚函数地址，虚函数表里是顺序存放虚函数地址的。

- 虚继承
虚继承是指一个指定的类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。说白了就是共享基类的数据！

当评价一个潜在的继承关系时，重要的因素是可替代性的行为，而不是子集。


虚指针或虚函数指针是一个虚函数的实现细节，带有虚函数的类的每个对象都有一个虚函数指针指向类的虚函数表。

虚函数的入口地址保存在vtable中的某一项中，而对象中的vptr指向vtable，再去寻找相应虚函数项，实现“动态联编”
